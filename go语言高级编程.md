# 语言基础

## 数组

- **定义**

  - ```go
    // 定义长度为3的int型数组, 元素全部为0
    var a [3]int                    
    ```

    > 定义一个数组变量的最基本的方式，数组的长度明确指定，数组中的每个元素都以零值初始化。

  - ```go
    // 定义长度为3的int型数组, 元素为 1, 2, 3
    var b = [...]int{1, 2, 3}
    ```

    > 定义数组，可以在定义的时候顺序指定全部元素的初始化值，数组的长度根据初始化元素的数目自动计算。

  - ```go
    // 定义长度为3的int型数组, 元素为 0, 2, 3
    var c = [...]int{2: 3, 1: 2}
    ```

    > 以索引的方式来初始化数组的元素，因此元素的初始化值出现顺序比较随意。
    >
    > 这种初始化方式和`map[int]Type`类型的初始化语法类似。
    >
    > 数组的**长度以出现的最大的索引为准**，没有明确初始化的元素依然用0值初始化。

  - ```go
    // 定义长度为6的int型数组, 元素为 1, 2, 0, 0, 5, 6
    var d = [...]int{1, 2, 4: 5, 6}
    ```

    > 混合了第二种和第三种的初始化方式，前面两个元素采用顺序初始化，第三第四个元素零值初始化，第五个元素通过索引初始化，最后一个元素跟在前面的第五个元素之后采用顺序初始化。

- **值语义**

- **数组指针**：数组指针类型不够灵活，因为数组的长度是数组类型的组成部分，指向不同长度数组的数组指针类型也是完全不同的。

## 字符串

```go
type StringHeader struct {
  Data uintptr
  Len  int
}
```

> 底层结构在`reflect.StringHeader`中定义。

- **不可改变**：字符串的元素不可修改，是一个只读的字节数组。
- **类型**：每个字符串的长度虽然是固定的，但是字符串的长度并不是字符串类型的一部分。
- **操作**：支持切片操作，不同位置的切片底层也访问的同一块内存数据。
- **uft-8**：Go语言的源文件都是采用UTF8编码。
  - 错误编码不会向后扩散是UTF8编码的优秀特性之一。

## 切片

```go
type SliceHeader struct {
  Data uintptr
  Len  int
  Cap  int
}
```

> 底层结构在`reflect.SliceHeader`中定义。

- **定义**

  ```go
  var (
    a []int               // nil切片, 和 nil 相等, 一般用来表示一个不存在的切片
    b = []int{}           // 空切片, 和 nil 不相等, 一般用来表示一个空的集合
    c = []int{1, 2, 3}    // 有3个元素的切片, len和cap都为3
    d = c[:2]             // 有2个元素的切片, len为2, cap为3
    e = c[0:2:cap(c)]     // 有2个元素的切片, len为2, cap为3
    f = c[:0]             // 有0个元素的切片, len为0, cap为3
    g = make([]int, 3)    // 有3个元素的切片, len和cap都为3
    h = make([]int, 2, 3) // 有2个元素的切片, len为2, cap为3
    i = make([]int, 0, 3) // 有0个元素的切片, len为0, cap为3
  )
  ```

- **类型**：切片的类型和长度信息无关，只要是相同类型元素构成的切片均对应相同的切片类型。

- **添加切片元素**

  - *尾部追加*

    ```go
    var a []int
    a = append(a, 1)               // 追加1个元素
    a = append(a, 1, 2, 3)         // 追加多个元素, 手写解包方式
    a = append(a, []int{1,2,3}...) // 追加一个切片, 切片需要解包
    ```

  - *开头添加*

    ```go
    var a = []int{1,2,3}
    a = append([]int{0}, a...)        // 在开头添加1个元素
    a = append([]int{-3,-2,-1}, a...) // 在开头添加1个切片
    ```

  - *中间添加*

    - **临时切片**

      ```go
      var a []int
      a = append(a[:i], append([]int{x}, a[i:]...)...)     // 在第i个位置插入x
      a = append(a[:i], append([]int{1,2,3}, a[i:]...)...) // 在第i个位置插入切片
      ```

    - **非临时切片**

      ```go
      a = append(a, x...)       // 为x切片扩展足够的空间
      copy(a[i+len(x):], a[i:]) // a[i:]向后移动len(x)个位置
      copy(a[i:], x)            // 复制新添加的切片
      ```

      > 可以用`copy`和`append`组合可以避免创建中间的临时切片。
      >
      > - 稍显不足的是，在第一句扩展切片容量的时候，扩展空间部分的元素复制是没有必要的。
      > - 没有专门的内置函数用于扩展切片的容量。

- **删除切片元素**

  - *尾部删除*

    ```go
    a = []int{1, 2, 3}
    a = a[:len(a)-1]   // 删除尾部1个元素
    a = a[:len(a)-N]   // 删除尾部N个元素
    ```

  - *开头删除*

    - **原地删除**

      ```go
      a = []int{1, 2, 3}
      a = a[1:] // 删除开头1个元素
      a = a[N:] // 删除开头N个元素
      ```

    - **append原地删除**

      ```go
      a = []int{1, 2, 3}
      a = append(a[:0], a[1:]...) // 删除开头1个元素
      a = append(a[:0], a[N:]...) // 删除开头N个元素
      ```

    - **copy原地删除**

      ```go
      a = []int{1, 2, 3}
      a = a[:copy(a, a[1:])] // 删除开头1个元素
      a = a[:copy(a, a[N:])] // 删除开头N个元素
      ```

  - *中间删除*

    ```go
    a = []int{1, 2, 3, ...}
    
    a = append(a[:i], a[i+1:]...) // 删除中间1个元素
    a = append(a[:i], a[i+N:]...) // 删除中间N个元素
    
    a = a[:i+copy(a[i:], a[i+1:])]  // 删除中间1个元素
    a = a[:i+copy(a[i:], a[i+N:])]  // 删除中间N个元素
    ```

### 切片内存技巧

```go
func TrimSpace(s []byte) []byte {
  b := s[:0]
  for _, x := range s {
    if x != ' ' {
      b = append(b, x)
    }
  }
  return b
}
```

> 根据过滤条件原地删除切片元素的算法都可以采用类似的方式处理。
>
> 切片高效操作的要点是要降低内存分配的次数，尽量保证`append`操作不会超出`cap`的容量，降低触发内存分配的次数和每次分配内存大小。

### 避免切片内存泄漏

- **因为一个小的内存引用而导致底层整个数组处于被使用的状态**。

  ```go
  func FindPhoneNumber(filename string) []byte {
    b, _ := ioutil.ReadFile(filename)
    b = regexp.MustCompile("[0-9]+").Find(b)
    return append([]byte{}, b...)
  }
  ```

  > 将需要的数据复制到一个新的切片。

- **当切片里存放的是指针对象，那么删除末尾的元素后，被删除的元素依然被切片底层数组引用，无法回收**。

  ```go
  var a []*int{ ... }
  a[len(a)-1] = nil // GC回收最后一个元素内存
  a = a[:len(a)-1]  // 从切片删除最后一个元素
  ```

  > 将要删除的元素置为nil。

### 切片类型强制转换

- 第一种强制转换是先将切片数据的开始地址转换为一个较大的数组的指针，然后对数组指针对应的数组重新做切片操作。

  ```go
  var b []int = ((*[1 << 20]int)(unsafe.Pointer(&a[0])))[:len(a):cap(a)]

- 第二种转换操作是分别取到两个不同类型的切片头信息指针，任何类型的切片头部信息底层都是对应`reflect.SliceHeader`结构，然后通过更新结构体方式来更新切片信息。

  ```go
  var c []int
  aHdr := (*reflect.SliceHeader)(unsafe.Pointer(&a))
  cHdr := (*reflect.SliceHeader)(unsafe.Pointer(&c))
  *cHdr = *aHdr
  ```

## 函数

> - 具名函数：对应于包级的函数，是匿名函数的一种特例。
>
> - 匿名函数：没有名字的函数。
>
> - 闭包函数：当匿名函数引用了外部作用域中的变量时就成了闭包函数。

在`main.main`函数执行之前所有代码都运行在同一个goroutine，也就是程序的主系统线程中。因此，如果某个`init`函数内部用go关键字启动了新的goroutine的话，新的goroutine只有在进入`main.main`函数之后才可能被执行到。

- **init**

  > - 一个包的多个`init`函数调用顺序未定义。
  > - 同一个文件内的多个`init`则是以出现的顺序依次调用。
  > - `init`不是普通函数，可以定义有多个，所以也不能被其它函数调用。

- **可变参数**：当可变参数是一个空接口类型时，调用者是否解包可变参数会导致不同的结果。

  ```go
  var a = []interface{}{123, "abc"}
  
  Print(a...) // 123 abc
  Print(a)    // [123 abc]
  
  func Print(a ...interface{}) {
    fmt.Println(a...)
  }
  ```

- **命名返回值**：如果返回值命名了，可以通过名字来修改返回值，也可以通过`defer`语句在`return`语句之后修改返回值。

  ```go
  func Inc() (v int) {
    defer func(){ v++ } ()
    return 42
  }
  ```

- **闭包的外部变量**：闭包对捕获的外部变量并不是传值方式访问，而是以引用的方式访问。

  - *问题*：`defer` 执行时外部变量的值和定义defer时的值不同。

  - *解决思路*

    > - 循环体内部再定义一个局部变量。
    > - 将迭代变量通过闭包函数的参数传入。
    > - **`defer`语句会马上对调用参数求值**。

- **堆和栈**

  ```go
  func f(x int) *int {
    return &x
  }
  ```

  > Go语言的编译器和运行时比我们聪明的多，它会保证指针指向的变量在合适的地方。

  ```go
  func g() int {
    x = new(int)
    return *x
  }
  ```

  > 不要假设变量在内存中的位置是固定不变的，指针随时可能会变化，特别是在你不期望它变化的时候。

## 方法

> 方法是绑定到一个具体类型的特殊函数，Go语言中的方法是依托于类型的，必须在编译时静态绑定。

### 接口

1. Go语言的接口类型是延迟绑定，可以实现类似虚函数的多态功能。
2. 对于基础类型（非接口类型）不支持隐式的转换。
3. 有时候对象和接口之间太灵活了，导致我们需要**人为地限制这种无意之间的适配**。
   1. 常见的做法是定义一个含特殊方法来区分接口。
   2. 再严格一点的做法是给接口定义一个私有方法。

